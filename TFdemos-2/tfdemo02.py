#coding=utf-8
"""
多层网络解决异或运算

"""

import tensorflow as tf
"""
感知机:简单理解为单层神经网络
感知机会将输入加权求和,然后再通过激活函数最后得到输出.
这个结构就是一个没有隐藏层的神经网络

感知机无法模拟异或运算
"""

#tip1
"""
tf.clip_by_value可以将一个张量中的数值限制在一个范围之内,
例如下面这段代码,运行之后,小于2.5的将被替换成2.5
大于4.5的将被替换成4.5
"""
sess = tf.Session()
v = tf.constant([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])
print(tf.clip_by_value(v, 2.5, 4.5).eval(session=sess))

#tip2
"""
tf.log函数可以完成对张量中所有元素依次求对数的功能
下面代码给出一个简单使用样例
"""
v = tf.constant([1.0, 2.0, 3.0])
print(tf.log(v).eval(session=sess))
print("********************我是分割线******************")

#tip3
"""
乘法运算
在实现交叉熵的代码中直接将两个矩阵通过"*"相乘.
这个操作不是矩阵乘法,而是元素之间直接相乘.
矩阵的乘法通过tf.matmul函数完成.
下面的代码给出两者的区别
"""
v1 = tf.constant([[1.0, 2.0], [3.0, 4.0]])
v2 = tf.constant([[5.0, 6.0], [7.0, 8.0]])
"""
"*"完成的是两个矩阵对应位置上两个数的乘积
tf.matmul完成的是正经的矩阵乘法
"""
print((v1*v2).eval(session=sess))
print("*****************我是分割线**********************")
print(tf.matmul(v1, v2).eval(session=sess))
